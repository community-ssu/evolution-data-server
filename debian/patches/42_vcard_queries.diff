Index: evolution-data-server/addressbook/libebook-dbus/e-book-query.c
===================================================================
--- evolution-data-server.orig/addressbook/libebook-dbus/e-book-query.c	2008-12-17 13:59:07.000000000 +0200
+++ evolution-data-server/addressbook/libebook-dbus/e-book-query.c	2008-12-17 14:19:31.000000000 +0200
@@ -195,11 +195,6 @@
 {
 	EBookQuery *ret;
 	
-	if (test != E_BOOK_QUERY_IS) {
-		g_warning ("Can only use IS with %s", G_STRFUNC);
-		return NULL;
-	}
-	
 	ret = g_new0 (EBookQuery, 1);
 	ret->type = E_BOOK_QUERY_TYPE_FIELD_TEST;
 	ret->query.field_test.field = 0;
@@ -472,6 +467,36 @@
 }
 
 static ESExpResult *
+func_contains_vcard(struct _ESExp *f, int argc, struct _ESExpResult **argv, void *data)
+{
+	GList **list = data;
+	ESExpResult *r;
+
+	if (argc == 2
+	    && argv[0]->type == ESEXP_RES_STRING
+	    && argv[1]->type == ESEXP_RES_STRING) {
+		char *propname = argv[0]->value.string;
+		char *str = argv[1]->value.string;
+
+		if (!strcmp (propname, "x-evolution-any-field")) {
+			*list = g_list_prepend (*list, e_book_query_any_field_contains (str));
+		}
+		else {
+			if (propname)
+				*list = g_list_prepend (*list,
+							e_book_query_vcard_field_test (propname,
+										       E_BOOK_QUERY_CONTAINS,
+										       str));
+		}
+	}
+
+	r = e_sexp_result_new(f, ESEXP_RES_BOOL);
+	r->value.bool = FALSE;
+
+	return r;
+}
+
+static ESExpResult *
 func_is(struct _ESExp *f, int argc, struct _ESExpResult **argv, void *data)
 {
 	GList **list = data;
@@ -547,6 +572,32 @@
 }
 
 static ESExpResult *
+func_beginswith_vcard(struct _ESExp *f, int argc, struct _ESExpResult **argv, void *data)
+{
+	GList **list = data;
+	ESExpResult *r;
+
+	if (argc == 2
+	    && argv[0]->type == ESEXP_RES_STRING
+	    && argv[1]->type == ESEXP_RES_STRING) {
+		char *propname = argv[0]->value.string;
+		char *str = argv[1]->value.string;
+
+		if (propname)
+			*list = g_list_prepend (*list,
+						e_book_query_vcard_field_test (propname,
+									       E_BOOK_QUERY_BEGINS_WITH,
+									       str));
+
+	}
+
+	r = e_sexp_result_new(f, ESEXP_RES_BOOL);
+	r->value.bool = FALSE;
+
+	return r;
+}
+
+static ESExpResult *
 func_endswith(struct _ESExp *f, int argc, struct _ESExpResult **argv, void *data)
 {
 	GList **list = data;
@@ -572,6 +623,31 @@
 }
 
 static ESExpResult *
+func_endswith_vcard(struct _ESExp *f, int argc, struct _ESExpResult **argv, void *data)
+{
+	GList **list = data;
+	ESExpResult *r;
+
+	if (argc == 2
+	    && argv[0]->type == ESEXP_RES_STRING
+	    && argv[1]->type == ESEXP_RES_STRING) {
+		char *propname = argv[0]->value.string;
+		char *str = argv[1]->value.string;
+
+		if (propname)
+			*list = g_list_prepend (*list,
+						e_book_query_vcard_field_test (propname,
+									       E_BOOK_QUERY_ENDS_WITH,
+									       str));
+	}
+
+	r = e_sexp_result_new(f, ESEXP_RES_BOOL);
+	r->value.bool = FALSE;
+
+	return r;
+}
+
+static ESExpResult *
 func_exists(struct _ESExp *f, int argc, struct _ESExpResult **argv, void *data)
 {
 	GList **list = data;
@@ -622,10 +698,13 @@
 	{ "or", func_or, 0 },
 	{ "not", func_not, 0 },
 	{ "contains", func_contains, 0 },
+	{ "contains_vcard", func_contains_vcard, 0 },
 	{ "is", func_is, 0 },
 	{ "is_vcard", func_is_vcard, 0 },
 	{ "beginswith", func_beginswith, 0 },
+	{ "beginswith_vcard", func_beginswith_vcard, 0 },	
 	{ "endswith", func_endswith, 0 },
+	{ "endswith_vcard", func_endswith_vcard, 0 },
 	{ "exists", func_exists, 0 },
 	{ "exists_vcard", func_exists_vcard, 0 },
 };
Index: evolution-data-server/addressbook/libedata-book-dbus/e-book-backend-sexp.c
===================================================================
--- evolution-data-server.orig/addressbook/libedata-book-dbus/e-book-backend-sexp.c	2008-12-17 13:59:07.000000000 +0200
+++ evolution-data-server/addressbook/libedata-book-dbus/e-book-backend-sexp.c	2008-12-17 13:59:07.000000000 +0200
@@ -404,6 +404,14 @@
 	return entry_compare (ctx, f, argc, argv, (char *(*)(const char*, const char*)) e_util_utf8_strstrcase);
 }
 
+static ESExpResult *
+func_contains_vcard(struct _ESExp *f, int argc, struct _ESExpResult **argv, void *data)
+{
+	SearchContext *ctx = data;
+
+	return vcard_compare (ctx, f, argc, argv, (char *(*)(const char*, const char*)) e_util_utf8_strstrcase);
+}
+
 static char *
 is_helper (const char *s1, const char *s2)
 {
@@ -433,11 +441,14 @@
 endswith_helper (const char *s1, const char *s2)
 {
 	char *p;
-	if ((p = (char*) e_util_utf8_strstrcase(s1, s2))
-	    && (strlen(p) == strlen(s2)))
-		return p;
-	else
-		return NULL;
+
+	while((p = (char*) e_util_utf8_strstrcase(s1, s2))) {
+		if ((strlen(p) == strlen(s2)))
+			return p;
+		else
+			s1 = g_utf8_next_char (p);
+	}
+	return NULL;
 }
 
 static ESExpResult *
@@ -448,6 +459,14 @@
 	return entry_compare (ctx, f, argc, argv, endswith_helper);
 }
 
+static ESExpResult *
+func_endswith_vcard(struct _ESExp *f, int argc, struct _ESExpResult **argv, void *data)
+{
+	SearchContext *ctx = data;
+
+	return vcard_compare (ctx, f, argc, argv, endswith_helper);
+}
+
 static char *
 beginswith_helper (const char *s1, const char *s2)
 {
@@ -468,6 +487,14 @@
 }
 
 static ESExpResult *
+func_beginswith_vcard(struct _ESExp *f, int argc, struct _ESExpResult **argv, void *data)
+{
+	SearchContext *ctx = data;
+
+	return vcard_compare (ctx, f, argc, argv, beginswith_helper);
+}
+
+static ESExpResult *
 func_exists(struct _ESExp *f, int argc, struct _ESExpResult **argv, void *data)
 {
 	SearchContext *ctx = data;
@@ -552,10 +579,13 @@
 				   doesn't execute everything, 0 otherwise */
 } symbols[] = {
 	{ "contains", func_contains, 0 },
+	{ "contains_vcard", func_contains_vcard, 0 },
 	{ "is", func_is, 0 },
 	{ "is_vcard", func_is_vcard, 0 },
 	{ "beginswith", func_beginswith, 0 },
+	{ "beginswith_vcard", func_beginswith_vcard, 0 },
 	{ "endswith", func_endswith, 0 },
+	{ "endswith_vcard", func_endswith_vcard, 0 },
 	{ "exists", func_exists, 0 },
 	{ "exists_vcard", func_exists_vcard, 0 },
 };
Index: evolution-data-server/addressbook/backends/file/e-book-backend-file-index.c
===================================================================
--- evolution-data-server.orig/addressbook/backends/file/e-book-backend-file-index.c	2008-12-17 13:59:07.000000000 +0200
+++ evolution-data-server/addressbook/backends/file/e-book-backend-file-index.c	2008-12-17 14:54:19.000000000 +0200
@@ -42,18 +42,24 @@
 
 static ESExpResult *test_always_fails (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata);
 static ESExpResult *test_generic_field_is_indexed (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata);
+static ESExpResult *test_generic_field_is_indexed_vcard (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata);
 
 static ESExpResult *is_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata);
+static ESExpResult *is_vcard_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata);
 static ESExpResult *beginswith_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata);
+static ESExpResult *beginswith_vcard_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata);
 
 static const EBookBackendFileIndexSExpSymbol sexp_symbols[] = {
   {"contains", test_always_fails, NULL},
+  {"contains_vcard", test_always_fails, NULL},
   {"is", test_generic_field_is_indexed, is_query},
+  {"is_vcard", test_generic_field_is_indexed_vcard, is_vcard_query},
   {"beginswith", test_generic_field_is_indexed, beginswith_query},
+  {"beginswith_vcard", test_generic_field_is_indexed_vcard, beginswith_vcard_query},
   {"endswith", test_always_fails, NULL},
+  {"endswith_vcard", test_always_fails, NULL},
   {"exists", test_always_fails, NULL},
   {"exists_vcard", test_always_fails, NULL},
-  {"is_vcard", test_always_fails, NULL},
 };
 
 /* structures used for maintaining the indexes */
@@ -542,7 +548,7 @@
  * something we have an index for or not
  */
 static ESExpResult *
-test_generic_field_is_indexed (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+real_test_generic_field_is_indexed (gboolean vcard_query, ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
 {
   ESExpResult *result = NULL;
   gint i = 0;
@@ -560,22 +566,45 @@
   {
     query_term = argv[0]->value.string;
 
-    for (i = 0; i < G_N_ELEMENTS (indexes); i++)
+    if (vcard_query)
     {
-      if (query_term && g_str_equal (query_term, indexes[i].query_term))
+      for (i = 0; i < G_N_ELEMENTS (indexes); i++)
       {
-        return result;
+        if (query_term && g_str_equal (query_term, indexes[i].vfield))
+        {
+          return result;
+        }
+      }
+    } else {
+      for (i = 0; i < G_N_ELEMENTS (indexes); i++)
+      {
+        if (query_term && g_str_equal (query_term, indexes[i].query_term))
+        {
+          return result;
+        }
       }
     }
+
   } else {
     g_warning (G_STRLOC ": Unexpected query structure");
   }
-  
+
   *(gboolean *)userdata = FALSE;
   g_debug (G_STRLOC ": failing the test");
 
   return result;
 }
+static ESExpResult *
+test_generic_field_is_indexed (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+{
+  return real_test_generic_field_is_indexed (FALSE, sexp, argc, argv, userdata);
+}
+
+static ESExpResult *
+test_generic_field_is_indexed_vcard (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+{
+  return real_test_generic_field_is_indexed (TRUE, sexp, argc, argv, userdata);
+}
 
 /* index operations themselves */
 
@@ -1007,8 +1036,24 @@
   }
 }
 
+static const char*
+find_query_term_for_vfield (const char *vfield)
+{
+  int i;
+  for (i = 0; i < G_N_ELEMENTS (indexes); i++)
+  {
+    if (0 == g_str_equal (vfield, indexes[i].vfield))
+    {
+      return indexes[i].query_term;
+    }
+  }
+  g_critical ("vcard-attribute %s is not indexed", vfield);
+
+  return NULL;
+}
+
 static ESExpResult *
-is_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+real_is_query (gboolean vcard_query, ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
 {
   EBookBackendFileIndex *index = (EBookBackendFileIndex *)userdata;
   EBookBackendFileIndexPrivate *priv = GET_PRIVATE (index);
@@ -1017,7 +1062,8 @@
   DBT index_dbt, id_dbt;
   DB *db = NULL;
   gint db_error = 0;
-  gchar *query_term = NULL, *query_key = NULL;
+  const gchar *query_term = NULL;
+  gchar *query_key = NULL;
   GPtrArray *ids = NULL;
   DBC *dbc = NULL;
 
@@ -1030,6 +1076,10 @@
   {
     /* we need the index database too */
     query_term = argv[0]->value.string;
+    if (vcard_query)
+    {
+      query_term = find_query_term_for_vfield (query_term);
+    }
     db = g_hash_table_lookup (priv->sdbs, query_term);
 
     /* populate a dbt for looking up in the index */
@@ -1089,7 +1139,19 @@
 }
 
 static ESExpResult *
-beginswith_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+is_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+{
+  return real_is_query (FALSE, sexp, argc, argv, userdata);
+}
+
+static ESExpResult *
+is_vcard_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+{
+  return real_is_query (TRUE, sexp, argc, argv, userdata);
+}
+
+static ESExpResult *
+real_beginswith_query (gboolean vcard_query, ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
 {
   EBookBackendFileIndex *index = (EBookBackendFileIndex *)userdata;
   EBookBackendFileIndexPrivate *priv = GET_PRIVATE (index);
@@ -1098,7 +1160,8 @@
   DBT index_dbt, id_dbt;
   DB *db = NULL;
   gint db_error = 0;
-  gchar *query_term = NULL, *query_key = NULL;
+  const gchar *query_term = NULL;
+  gchar *query_key = NULL;
   GPtrArray *ids = NULL;
   DBC *dbc = NULL;
 
@@ -1111,6 +1174,10 @@
   {
     /* we need the index database too */
     query_term = argv[0]->value.string;
+    if (vcard_query)
+    {
+      query_term = find_query_term_for_vfield (query_term);
+    }
     db = g_hash_table_lookup (priv->sdbs, query_term);
 
     /* populate a dbt for looking up in the index */
@@ -1179,6 +1246,18 @@
   return result;
 }
 
+static ESExpResult *
+beginswith_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+{
+  return real_beginswith_query (FALSE, sexp, argc, argv, userdata);
+}
+
+static ESExpResult *
+beginswith_vcard_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+{
+  return real_beginswith_query (TRUE, sexp, argc, argv, userdata);
+}
+
 static gboolean
 index_close_db_func (gpointer key, gpointer value, gpointer userdata)
 {
