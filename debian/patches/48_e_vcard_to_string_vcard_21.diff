Index: evolution-data-server/addressbook/libebook-dbus/e-vcard.c
===================================================================
--- evolution-data-server.orig/addressbook/libebook-dbus/e-vcard.c	2008-11-18 14:01:27.000000000 +0100
+++ evolution-data-server/addressbook/libebook-dbus/e-vcard.c	2008-11-18 14:01:27.000000000 +0100
@@ -73,6 +73,10 @@
 static size_t _evc_base64_decode_simple (char *data, size_t len);
 static char  *_evc_base64_encode_simple (const char *data, size_t len);
 
+static char * _evc_quoted_printable_decode (const char *input);
+static char * _evc_quoted_printable_encode (const char *input, size_t size, gboolean *is_qp);
+static char * _evc_escape_string_21 (const char *s);
+
 static void e_vcard_attribute_param_add_value_with_len (EVCardAttributeParam *param, const char *value, int length);
 
 static void
@@ -825,11 +829,152 @@
 	return evc;
 }
 
+
 static char*
-e_vcard_to_string_vcard_21  (EVCard *evc)
+e_vcard_to_string_vcard_21 (EVCard *evc)
 {
-	g_warning ("need to implement e_vcard_to_string_vcard_21");
-	return g_strdup ("");
+        GList *l;
+        GList *v;
+        GString *str;
+
+        str = g_string_new ("BEGIN:VCARD" CRLF "VERSION:2.1" CRLF);
+
+	for (l = e_vcard_ensure_attributes (evc); l; l = l->next) {
+		GList *p;
+		EVCardAttribute *attr = l->data;
+		GString *attr_str;
+                GString *value_str;
+                gboolean qp_set = FALSE;
+
+                /* Skip the version attribute since we are outputting to
+                 * version 2.1 */
+		if (!strcmp (attr->name, "VERSION"))
+			continue;
+
+		attr_str = g_string_new ("");
+
+		/* Groupping */
+		if (attr->group) {
+			g_string_append (attr_str, attr->group);
+			g_string_append_c (attr_str, '.');
+		}
+		g_string_append (attr_str, attr->name);
+
+                if (attr->encoding_set) {
+                        switch (attr->encoding) {
+                                case EVC_ENCODING_BASE64:
+                                        g_string_append (attr_str, ";ENCODING=BASE64");
+                                        break;
+                                case EVC_ENCODING_QP:
+                                        g_string_append (attr_str, ";ENCODING=QUOTED-PRINTABLE");
+                                        qp_set = TRUE;
+                                        break;
+                                default:
+                                        g_warning ("wrong encoding type");
+                        }
+                }
+		/* handle the parameters */
+		for (p = attr->params; p; p = p->next) {
+			EVCardAttributeParam *param = p->data;
+
+                        /* skip the encoding parameter */
+                        if (!g_ascii_strcasecmp (param->name, EVC_ENCODING))
+                                continue;
+
+                        g_string_append_c (attr_str, ';');
+
+			g_string_append (attr_str, param->name);
+			if (param->values) {
+				g_string_append_c (attr_str, '=');
+				for (v = param->values; v; v = v->next) {
+					char *value = v->data;
+					char *p = value;
+					gboolean quotes = FALSE;
+					while (*p) {
+						if (!g_unichar_isalnum (g_utf8_get_char (p))) {
+							quotes = TRUE;
+							break;
+						}
+						p = g_utf8_next_char (p);
+					}
+					if (quotes)
+						g_string_append_c (attr_str, '"');
+					g_string_append (attr_str, value);
+					if (quotes)
+						g_string_append_c (attr_str, '"');
+					if (v->next)
+						g_string_append_c (attr_str, ',');
+				}
+			}
+		}
+
+                /* handle the values */
+                value_str = g_string_new (":");
+		for (v = attr->values; v; v = v->next) {
+			char *value = v->data;
+			char *escaped_value = NULL;
+
+                        escaped_value = _evc_escape_string_21 (value);
+
+                        if (attr->encoding == EVC_ENCODING_RAW) {
+                                gboolean is_qp = FALSE;
+                                char *qp_str = _evc_quoted_printable_encode (escaped_value, strlen (escaped_value), &is_qp);
+                                if (is_qp && !qp_set) {
+                                        attr_str = g_string_append (attr_str, ";ENCODING=QUOTED-PRINTABLE");
+                                        qp_set = TRUE;
+                                }
+                                g_string_append (value_str, qp_str);
+                                g_free (qp_str);
+                        }
+                        else {
+			        g_string_append (value_str, escaped_value);
+                        }
+			if (v->next) {
+				/* XXX toshok - i hate you, rfc 2426.
+				   why doesn't CATEGORIES use a ; like
+				   a normal list attribute? */
+				if (!strcmp (attr->name, "CATEGORIES"))
+					g_string_append_c (value_str, ',');
+				else
+					g_string_append_c (value_str, ';');
+			}
+
+			g_free (escaped_value);
+		}
+                g_string_append (attr_str, value_str->str);
+                g_string_free (value_str, TRUE);
+
+		/* lines longer than 75 characters SHOULD be folded */
+                if (qp_set && attr_str->len > 75) {
+                        int l = 0;
+
+                        do {
+                                /* insert soft line break */
+                                if ((attr_str->len - l) > 75) {
+                                        l += 75;
+
+                                        /* we don't want to break line inside an encoded value */
+                                        if (*(attr_str->str + l-1) == '=')
+                                                l -= 1;
+                                        else if (*(attr_str->str + l-2) == '=')
+                                                l -= 2;
+
+                                        g_string_insert_len (attr_str, l, "="CRLF, sizeof ("="CRLF) - 1);
+                                        l += 3; /* because of the inserted characters */
+                                }
+                                else {
+                                        break;
+                                }
+                        } while (l < attr_str->len);
+                }
+
+		g_string_append_printf (str, "%s"CRLF, attr_str->str);
+		g_string_free (attr_str, TRUE);
+	}
+
+	g_string_append (str, "END:VCARD");
+
+	return g_string_free (str, FALSE);
 }
 
 static char*
@@ -2253,3 +2398,136 @@
 	return _evc_base64_decode_step ((unsigned char *)data, len,
 					(unsigned char *)data, &state, &save);
 }
+
+/**
+ * _evc_quoted_printable_decode: decodes quoted-printable text into
+ * raw format.
+ * @input: Input string in quoted-printable form.
+ *
+ * Decodes quoted-printable text into raw format. It removes soft line breaks
+ * but doesn't handle escaped characters. #e_vcard_unescape_string should be
+ * calld after this function if unescaping is needed.
+ *
+ * Return value: a newly allocated text in raw format
+ */
+static char *
+_evc_quoted_printable_decode (const char *input)
+{
+        GString *output;
+
+        output = g_string_new ("");
+
+        for (; input && *input; input++) {
+                /* special character follows */
+                if (*input == '=') {
+                        char a, b;
+
+                        a = *(++input);
+                        b = *(++input);
+
+                        if (a == '\r' && b == '\n') {
+                                /* skip soft line break */
+                                continue;
+                        }
+                        else if (g_ascii_isxdigit(a) && g_ascii_isxdigit(b)) {
+                                /* decode the hexadecimal value to unicode
+                                 * character */
+                                output = g_string_append_c (output, g_ascii_xdigit_value (a) * 16 +
+                                                            g_ascii_xdigit_value (b));
+                        }
+                        else {
+                                output = g_string_append_c (output, a);
+                                output = g_string_append_c (output, b);
+                        }
+                }
+                else {
+                        output = g_string_append_c (output, *input);
+                }
+        }
+
+        return g_string_free (output, FALSE);
+}
+
+/**
+ * _evc_quoted_printable_encode: encodes a string into quoted-printable form.
+ * @input: input string in raw format.
+ * @size: size of the input buffer.
+ * @is_qp: TRUE if the encoded string contains any special quoted-printabel
+ * character, FALSE if the return value can be ignored because its the same as
+ * @input.
+ *
+ * Encodes a raw string into quoted-printable form. It inserts soft line
+ * breaks, but doesn't escapes special characters, if its needed then it
+ * should be done before this function call with _evc_escape_string_21 function.
+ *
+ * Return value: a newly allocated string in quoted-printable format.
+ */
+static char *
+_evc_quoted_printable_encode (const char *input, size_t size, gboolean *is_qp)
+{
+        GString *output;
+        int l;
+
+        output = g_string_new ("");
+        *is_qp = FALSE;
+
+        /* convert the char to quoted-printable sequence */
+        for (l = 0; l < size; l++, input++) {
+                unsigned char ch = *input;
+
+                /* printable ASCII characters, SPACE and HTAB */
+                if ( (ch > 31 && ch < 61) || (ch > 61 && ch < 127) || ch == 9 ) {
+                        output = g_string_append_c (output, ch);
+                }
+                else {
+                        g_string_append_printf (output, "=%02X", ch);
+                        *is_qp = TRUE;
+                }
+        }
+
+        return g_string_free (output, FALSE);
+}
+
+/**
+ * _evc_escape_string_21:
+ * @s: the string to escape
+ *
+ * Escapes a string according to vCard 2.1 specifications.
+ *
+ * Return value: A newly allocated, escaped string.
+ **/
+static char *
+_evc_escape_string_21 (const char *s)
+{
+	GString *str;
+	const char *p;
+
+	str = g_string_new ("");
+
+	/* Escape a string as described in vCard 2.1 specification */
+	for (p = s; p && *p; p++) {
+		switch (*p) {
+		case '\n':
+			g_string_append (str, "\\n");
+			break;
+		case '\r':
+			g_string_append (str, "\\r");
+			break;
+		case ';':
+			g_string_append (str, "\\;");
+			break;
+		case ',':
+			g_string_append (str, "\\,");
+			break;
+		case '\\':
+			g_string_append (str, "\\\\");
+			break;
+		default:
+			g_string_append_c (str, *p);
+			break;
+		}
+	}
+
+	return g_string_free (str, FALSE);
+}
+
