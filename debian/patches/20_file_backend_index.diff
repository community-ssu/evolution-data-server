Index: git/addressbook/backends/file/Makefile.am
===================================================================
--- git.orig/addressbook/backends/file/Makefile.am	2008-05-12 11:33:41.000000000 +0100
+++ git/addressbook/backends/file/Makefile.am	2008-05-12 11:33:42.000000000 +0100
@@ -12,6 +12,8 @@
 libebookbackendfile_la_SOURCES =			\
 	e-book-backend-file.c				\
 	e-book-backend-file.h				\
+	e-book-backend-file-index.c				\
+	e-book-backend-file-index.h				\
 	e-book-backend-file-factory.c			\
 	$(top_srcdir)/libedataserver/e-db3-utils.c	\
 	$(top_srcdir)/libedataserver/e-dbhash.c
Index: git/addressbook/backends/file/e-book-backend-file.c
===================================================================
--- git.orig/addressbook/backends/file/e-book-backend-file.c	2008-05-12 11:33:41.000000000 +0100
+++ git/addressbook/backends/file/e-book-backend-file.c	2008-05-12 12:11:24.000000000 +0100
@@ -54,6 +54,8 @@
 
 #include "e-book-backend-file.h"
 
+#include "e-book-backend-file-index.h"
+
 #define d(x)
 
 #define CHANGES_DB_SUFFIX ".changes.db"
@@ -73,6 +75,7 @@
 	DB       *file_db;
 	DB_ENV   *env;
 	EBookBackendSummary *summary;
+	EBookBackendFileIndex *index;
 };
 
 G_LOCK_DEFINE_STATIC (global_env);
@@ -246,6 +249,7 @@
 	status = do_create (bf, vcard, contact);
 	if (status == GNOME_Evolution_Addressbook_Success) {
 		e_book_backend_summary_add_contact (bf->priv->summary, *contact);
+		e_book_backend_file_index_add_contact (bf->priv->index, *contact);
 	}
 	return status;
 }
@@ -293,6 +297,7 @@
 	for (l = removed_cards; l; l = l->next) {
 		char *id = l->data;
 		e_book_backend_summary_remove_contact (bf->priv->summary, id);
+		e_book_backend_file_index_remove_contact (bf->priv->index, id);
 	}
 
 	return rv;
@@ -345,6 +350,7 @@
 	g_free (vcard_with_rev);
 	
 	if (db_error == 0) {
+		e_book_backend_file_index_modify_contact (bf->priv->index, *contact);
 		return GNOME_Evolution_Addressbook_Success;
 	} else {
 		g_warning (G_STRLOC ": db->put failed with %s", db_strerror (db_error));
@@ -642,11 +648,45 @@
 	d(printf ("signalling parent thread\n"));
 	e_flag_set (closure->running);
 
-	if (e_book_backend_summary_is_summary_query (bf->priv->summary, query)) {
+	g_debug (G_STRLOC ": Query is %s", query);
+	if (e_book_backend_file_index_is_usable (bf->priv->index, query))
+	{
+		GPtrArray *ids = NULL;
+		int i;
+
+		g_debug (G_STRLOC ": Using index for %s", query);
+
+		ids = e_book_backend_file_index_query (bf->priv->index, query);
+
+		for (i = 0; i < ids->len; i ++) {
+			char *id = g_ptr_array_index (ids, i);
+
+			if (!e_flag_is_set (closure->running))
+				break;
+
+			string_to_dbt (id, &id_dbt);
+			memset (&vcard_dbt, 0, sizeof (vcard_dbt));
+			vcard_dbt.flags = DB_DBT_MALLOC;
+
+			db_error = db->get (db, NULL, &id_dbt, &vcard_dbt, 0);
+
+			if (db_error == 0) {
+				e_data_book_view_notify_update_prefiltered_vcard (book_view, id, vcard_dbt.data);
+			}
+			else {
+				g_warning (G_STRLOC ": db->get failed with %s", db_strerror (db_error));
+			}
+		}
+
+		e_book_backend_file_index_finish_query (bf->priv->index);
+		g_ptr_array_free (ids, TRUE);
+	} else if (e_book_backend_summary_is_summary_query (bf->priv->summary, query)) {
 		/* do a summary query */
 		GPtrArray *ids = e_book_backend_summary_search (bf->priv->summary, e_data_book_view_get_card_query (book_view));
 		int i;
 
+		g_debug (G_STRLOC ": Using summmary for %s", query);
+
 		for (i = 0; i < ids->len; i ++) {
 			char *id = g_ptr_array_index (ids, i);
 
@@ -668,8 +708,7 @@
 		}
 
 		g_ptr_array_free (ids, TRUE);
-	}
-	else {
+	} else {
 		/* iterate over the db and do the query there */
 		DBC    *dbc;
 
@@ -709,13 +748,14 @@
 				   bf->priv->filename);
 			abort ();
 		}
-
-
 	}
 
 	if (e_flag_is_set (closure->running))
+	{
 		e_data_book_view_notify_complete (book_view, GNOME_Evolution_Addressbook_Success);
 
+	}
+
 	/* unref the */
 	g_object_unref (book_view);
 
@@ -1143,6 +1183,8 @@
 	time_t db_mtime;
 	struct stat sb;
 	gchar *uri;
+	gchar *index_filename;
+
 
 	uri = e_source_get_uri (source);
 
@@ -1317,12 +1359,22 @@
 	g_free (bf->priv->summary_filename);
 	bf->priv->summary_filename = g_strconcat (bf->priv->filename, ".summary", NULL);
 	bf->priv->summary = e_book_backend_summary_new (bf->priv->summary_filename, SUMMARY_FLUSH_TIMEOUT);
-
 	if (e_book_backend_summary_is_up_to_date (bf->priv->summary, db_mtime) == FALSE
 	    || e_book_backend_summary_load (bf->priv->summary) == FALSE ) {
 		build_summary (bf->priv);
 	}
 
+
+	bf->priv->index = e_book_backend_file_index_new ();
+	index_filename = g_build_filename (bf->priv->dirname, "index.db", NULL);
+
+	G_LOCK (global_env);
+	global_env.ref_count++;
+	G_UNLOCK (global_env);
+
+	e_book_backend_file_index_setup_indicies (bf->priv->index, db, index_filename);
+	g_free (index_filename);
+
 	e_book_backend_set_is_loaded (backend, TRUE);
 	e_book_backend_set_is_writable (backend, writable);
 	return GNOME_Evolution_Addressbook_Success;
@@ -1474,6 +1526,14 @@
 	}
 	
 	G_LOCK (global_env);
+	if (bf->priv->index) {
+		global_env.ref_count--;
+		g_object_unref (bf->priv->index);
+		bf->priv->index = NULL;
+	}
+	G_UNLOCK (global_env);
+	
+	G_LOCK (global_env);
 	global_env.ref_count--;
 	if (global_env.ref_count == 0) {
 		global_env.env->close (global_env.env, 0);
Index: git/addressbook/backends/file/e-book-backend-file-index.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/addressbook/backends/file/e-book-backend-file-index.c	2008-05-12 12:12:22.000000000 +0100
@@ -0,0 +1,861 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of version 2 of the GNU Lesser General Public License as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Author: Rob Bradford <rob@openedhand.com>
+ */
+
+#include "e-book-backend-file-index.h"
+#include "libedataserver/e-sexp.h"
+#include "libebook/e-contact.h"
+
+#include "db.h"
+
+#include <string.h>
+#include <errno.h>
+
+G_DEFINE_TYPE (EBookBackendFileIndex, e_book_backend_file_index, G_TYPE_OBJECT)
+
+#define GET_PRIVATE(o) \
+  (G_TYPE_INSTANCE_GET_PRIVATE ((o), E_TYPE_BOOK_BACKEND_FILE_INDEX, EBookBackendFileIndexPrivate))
+
+/* structures used for the parsing side of things */
+
+typedef struct 
+{
+  gchar *name;            /* function name */
+  ESExpFunc *test_function;   /* for just testing to see if we can use the index */
+  ESExpFunc *result_function; /* for actually producing a result */
+} EBookBackendFileIndexSExpSymbol;
+
+static ESExpResult *test_always_fails (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata);
+static ESExpResult *test_generic_field_is_indexed (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata);
+
+static ESExpResult *is_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata);
+static ESExpResult *beginswith_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata);
+
+static const EBookBackendFileIndexSExpSymbol sexp_symbols[] = {
+  {"contains", test_always_fails, NULL},
+  {"is", test_generic_field_is_indexed, is_query},
+  {"beginswith", test_generic_field_is_indexed, beginswith_query},
+  {"endswith", test_always_fails, NULL},
+  {"exists", test_always_fails, NULL},
+  {"exists_vcard", test_always_fails, NULL},
+  {"is_vcard", test_always_fails, NULL},
+};
+
+/* structures used for maintaining the indexes */
+typedef enum
+{
+  INDEX_FIELD_TYPE_STRING = 0,     /* single string */
+  INDEX_FIELD_TYPE_STRING_LIST /* list of strings */
+} EBookBackendFileIndexFieldType;
+
+typedef struct 
+{
+  gchar *query_term;                    /* what the query uses to get this */
+  gchar *index_name;                    /* name for index */
+  gchar *vfield;                        /* the (vcard) field this an index of */
+} EBookBackendFileIndexData;
+
+static const EBookBackendFileIndexData indexes[] = {
+  {"full-name", "full_name", EVC_FN},
+  {"im-jabber", "im_jabber", EVC_X_JABBER},
+  {"tel", "tel", EVC_TEL},
+  {"email", "email", EVC_EMAIL},
+};
+
+typedef struct _EBookBackendFileIndexPrivate EBookBackendFileIndexPrivate;
+
+struct _EBookBackendFileIndexPrivate {
+  DB *db;  /* primary database */
+  GHashTable *sdbs; /* mapping for query->term to database used for it */
+  GList *ids_to_free; /* a list of ids to free in the _finish call */
+};
+
+static gboolean index_populate (EBookBackendFileIndex *index, GList *fields);
+static void index_add_contact (EBookBackendFileIndex *index, EContact *contact, 
+    EBookBackendFileIndexData *data);
+static void index_remove_contact (EBookBackendFileIndex *index, const gchar *uid, 
+    EBookBackendFileIndexData *data);
+static gboolean index_close_db_func (gpointer key, gpointer value, gpointer userdata);
+
+#define E_BOOK_BACKEND_FILE_VERSION_NAME "PAS-DB-VERSION"
+
+static void
+e_book_backend_file_index_dispose (GObject *object)
+{
+  EBookBackendFileIndex *index = (EBookBackendFileIndex *)object;
+  EBookBackendFileIndexPrivate *priv = GET_PRIVATE (index);
+
+  if (priv->sdbs)
+  {
+    /* close all the open index databases */
+    g_hash_table_foreach_remove (priv->sdbs, index_close_db_func, 
+        E_BOOK_BACKEND_FILE_INDEX (object));
+
+    g_hash_table_unref (priv->sdbs);
+    priv->sdbs = NULL;
+  }
+
+  /* free any ids we may have left from a query */
+  e_book_backend_file_index_finish_query (index);
+
+  if (G_OBJECT_CLASS (e_book_backend_file_index_parent_class)->dispose)
+    G_OBJECT_CLASS (e_book_backend_file_index_parent_class)->dispose (object);
+}
+
+static void
+e_book_backend_file_index_finalize (GObject *object)
+{
+  if (G_OBJECT_CLASS (e_book_backend_file_index_parent_class)->finalize)
+    G_OBJECT_CLASS (e_book_backend_file_index_parent_class)->finalize (object);
+}
+
+static void
+e_book_backend_file_index_class_init (EBookBackendFileIndexClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (EBookBackendFileIndexPrivate));
+
+  object_class->dispose = e_book_backend_file_index_dispose;
+  object_class->finalize = e_book_backend_file_index_finalize;
+}
+
+static void
+e_book_backend_file_index_init (EBookBackendFileIndex *self)
+{
+  EBookBackendFileIndexPrivate *priv = GET_PRIVATE (self);
+
+  priv->sdbs = g_hash_table_new (g_str_hash, g_str_equal);
+}
+
+/* 'public' api */
+EBookBackendFileIndex *
+e_book_backend_file_index_new (void)
+{
+  return g_object_new (E_TYPE_BOOK_BACKEND_FILE_INDEX, NULL);
+}
+
+/* can we use the index on this query, yay or nay ? */
+gboolean
+e_book_backend_file_index_is_usable (EBookBackendFileIndex *index, const gchar *query)
+{
+  ESExp *sexp = NULL;
+  ESExpResult *sexp_result = NULL;
+  gint i = 0;
+  gint sexp_error = 0;
+  gboolean res = TRUE; /* whether we can actually use the index */
+
+  if (g_getenv ("_EDS_FILE_BACKEND_NO_INDEX"))
+    return FALSE;
+
+  sexp = e_sexp_new ();
+
+  /* Now add the 'test' functions, we just use these to find out whether we
+   * can do a query. They return booleans and then ESexp logic should figure
+   * out the logic...
+   */
+  for (i = 0; i < G_N_ELEMENTS (sexp_symbols); i++)
+  {
+    e_sexp_add_function (sexp, 0, sexp_symbols[i].name, 
+        sexp_symbols[i].test_function, &res);
+  }
+
+  /* Pull in the query as the text for the s-exp */
+  e_sexp_input_text (sexp, query, strlen (query));
+  sexp_error = e_sexp_parse (sexp);
+
+  if (sexp_error == -1)
+  {
+    g_warning (G_STRLOC ": Failed to parse query %s, %s", query, e_sexp_error (sexp));
+    e_sexp_unref (sexp);
+    return FALSE;
+  }
+
+  /* evaluate ... */
+  sexp_result = e_sexp_eval(sexp);
+
+  /* and then ignore the result */
+  e_sexp_result_free (sexp, sexp_result);
+  e_sexp_unref (sexp);
+
+  g_debug (G_STRLOC ": able to use index %s", res ? "yes": "no");
+
+  return res;
+}
+
+GPtrArray *
+e_book_backend_file_index_query (EBookBackendFileIndex *index, const gchar *query)
+{
+  ESExp *sexp = NULL;
+  ESExpResult *sexp_result = NULL;
+  gint i = 0;
+  gint sexp_error = 0;
+  GPtrArray *res = NULL;
+
+  sexp = e_sexp_new ();
+
+  g_debug (G_STRLOC ": Using query %s", query);
+
+  /* Now add the 'test' functions, we just use these to find out whether we
+   * can do a query. They return booleans and then ESexp logic should figure
+   * out the logic...
+   */
+  for (i = 0; i < G_N_ELEMENTS (sexp_symbols); i++)
+  {
+    e_sexp_add_function (sexp, 0, sexp_symbols[i].name, 
+        sexp_symbols[i].result_function, index);
+  }
+
+  /* Pull in the query as the text for the s-exp */
+  e_sexp_input_text (sexp, query, strlen (query));
+  sexp_error = e_sexp_parse (sexp);
+
+  if (sexp_error == -1)
+  {
+    g_warning (G_STRLOC ": Failed to parse query %s, %s", query, e_sexp_error (sexp));
+    e_sexp_unref (sexp);
+    return NULL;
+  }
+
+  /* evaluate ... */
+  sexp_result = e_sexp_eval(sexp);
+
+  if (sexp_result)
+  {
+    if (sexp_result->type == ESEXP_RES_ARRAY_PTR)
+    {
+      /* we have to copy everything into a new GPtrArray because the old one
+       * gets freed with e_sexp_result_free. :-(
+       */
+      res = g_ptr_array_sized_new (sexp_result->value.ptrarray->len);
+
+      for (i = 0; i < sexp_result->value.ptrarray->len; i ++)
+      {
+        g_ptr_array_add (res, g_ptr_array_index (sexp_result->value.ptrarray, i));
+      }
+
+      e_sexp_result_free (sexp, sexp_result);
+    } else {
+      g_warning (G_STRLOC ": Unexpected result type");
+    }
+  }
+
+  e_sexp_unref (sexp);
+  return res;
+}
+
+void
+e_book_backend_file_index_finish_query (EBookBackendFileIndex *index)
+{
+  EBookBackendFileIndexPrivate *priv = GET_PRIVATE (index);
+  GList *l = NULL;
+
+  for (l = priv->ids_to_free; l != NULL; l = l->next)
+  {
+    g_free (l->data);
+  }
+
+  g_list_free (priv->ids_to_free);
+  priv->ids_to_free = NULL;
+}
+
+/* setup indicies in index_filename for the primary database db */
+gboolean
+e_book_backend_file_index_setup_indicies (EBookBackendFileIndex *index, DB *db, 
+    const gchar *index_filename)
+{
+  EBookBackendFileIndexPrivate *priv = GET_PRIVATE (index);
+
+  GList *dbs_to_populate = NULL; /* list of EBookBackendFileIndexData to populate */
+  int db_error = 0;
+  int i = 0;
+  DB *sdb = NULL;
+  DB_ENV *env = NULL;
+
+  /* for each database we go through and try and create it exclusively, if
+   * that fails then we know that we don't need to populate it so we go and
+   * create it anyway and add it for the list of databases to populate */
+
+  g_return_val_if_fail (db != NULL, FALSE);
+  priv->db = db;
+
+  db_error = db->get_env (db, &env);
+
+  for (i = 0; i < G_N_ELEMENTS (indexes); i++)
+  {
+    db_error = db_create (&sdb, env, 0);
+
+    if (db_error != 0) {
+      g_warning (G_STRLOC ": db_create failed: %s", db_strerror (db_error));
+      return FALSE;
+    }
+
+    db_error = sdb->set_flags(sdb, DB_DUP | DB_DUPSORT);
+    if (db_error != 0) {
+      g_warning (G_STRLOC ":set_flags failed: %s", db_strerror (db_error));
+    }
+
+    db_error = sdb->open (sdb, NULL, index_filename, 
+        indexes[i].index_name, DB_BTREE, DB_CREATE | DB_EXCL | DB_THREAD, 0666);
+
+    if (db_error == EEXIST) {
+
+      /* try and open again, this time without exclusivity */
+      db_error = sdb->open (sdb, NULL, index_filename,
+          indexes[i].index_name, DB_BTREE, DB_CREATE | DB_THREAD, 0666);
+
+      if (db_error != 0)
+      {
+        g_warning (G_STRLOC ": open failed: %s", db_strerror (db_error));
+        sdb->close (sdb, 0);
+        return FALSE;
+      }
+    } else if (db_error != 0) {
+      if (db_error != 0)
+      {
+        g_warning (G_STRLOC ": open failed: %s", db_strerror (db_error));
+        sdb->close (sdb, 0);
+        return FALSE;
+      }
+    } else {
+      /* we know need to populate this one */
+      dbs_to_populate = g_list_prepend (dbs_to_populate, (gpointer)&(indexes[i]));
+    }
+
+    /* add it to the hash table of mappings of query term to database */
+    g_hash_table_insert (priv->sdbs, indexes[i].query_term, sdb);
+  }
+
+  /* now go through and populate these */
+  if (dbs_to_populate)
+  {
+    if (!index_populate (index, dbs_to_populate))
+    {
+      g_warning (G_STRLOC ": Error whilst trying to populate the index");
+      g_list_free (dbs_to_populate);
+      return FALSE;
+    }
+    g_list_free (dbs_to_populate);
+  }
+
+  return TRUE;
+}
+
+void
+e_book_backend_file_index_add_contact (EBookBackendFileIndex *index, EContact *contact)
+{
+  gint i = 0;
+
+  /* for each index database try add this contact */
+  for (i = 0; i < G_N_ELEMENTS (indexes); i++)
+  {
+    index_add_contact (index, contact, (EBookBackendFileIndexData *)&indexes[i]);
+  }
+}
+
+void
+e_book_backend_file_index_remove_contact (EBookBackendFileIndex *index, const gchar *uid)
+{
+  gint i = 0;
+
+  /* for each index database try add this contact */
+  for (i = 0; i < G_N_ELEMENTS (indexes); i++)
+  {
+    index_remove_contact (index, uid, (EBookBackendFileIndexData *)&indexes[i]);
+  }
+}
+
+void
+e_book_backend_file_index_modify_contact (EBookBackendFileIndex *index, EContact *contact)
+{
+  gchar *uid = NULL;
+  gint i = 0;
+
+  uid = (gchar *)e_contact_get (contact, E_CONTACT_UID);
+
+  /* for each index database try add this contact */
+  for (i = 0; i < G_N_ELEMENTS (indexes); i++)
+  {
+    index_remove_contact (index, uid, (EBookBackendFileIndexData *)&indexes[i]);
+    index_add_contact (index, contact, (EBookBackendFileIndexData *)&indexes[i]);
+  }
+
+  g_free (uid);
+}
+
+/* functions used for testing whether we can use the index */
+
+/* always return false since we can't handle that type of query */
+static ESExpResult *
+test_always_fails (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+{
+  ESExpResult *result;
+
+  result = e_sexp_result_new (sexp, ESEXP_RES_BOOL);
+
+  *(gboolean *)userdata = FALSE;
+
+  g_debug (G_STRLOC ": failing the test");
+  return result;
+}
+
+/* 
+ * return true or false based on whether we recognise that query field as
+ * something we have an index for or not
+ */
+static ESExpResult *
+test_generic_field_is_indexed (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+{
+  ESExpResult *result = NULL;
+  gint i = 0;
+  gchar *query_term = NULL;
+
+  result = e_sexp_result_new (sexp, ESEXP_RES_BOOL);
+
+  /* set to false now, we may set it to true in the loop below */
+  result->value.bool = FALSE;
+
+  /* we must have two arguments and they must both be strings */
+  if (argc == 2 &&
+      argv[0]->type == ESEXP_RES_STRING &&
+      argv[1]->type == ESEXP_RES_STRING)
+  {
+    query_term = argv[0]->value.string;
+
+    for (i = 0; i < G_N_ELEMENTS (indexes); i++)
+    {
+      if (query_term && g_str_equal (query_term, indexes[i].query_term))
+      {
+        return result;
+      }
+    }
+  } else {
+    g_warning (G_STRLOC ": Unexpected query structure");
+  }
+  
+  *(gboolean *)userdata = FALSE;
+  g_debug (G_STRLOC ": failing the test");
+}
+
+/* index operations themselves */
+
+/* boring helper function */
+static void
+dbt_fill_with_string (DBT *dbt, gchar *str)
+{
+  memset (dbt, 0, sizeof (DBT));
+  dbt->data = (void *)str;
+  dbt->size = strlen (str) + 1;
+  dbt->flags = DB_DBT_USERMEM;
+}
+
+/* when given a list of fields, walk through the primary database, walk
+ * through all contacts, parse them, then call the function to add to each
+ * index that needs updating
+ */
+static gboolean 
+index_populate (EBookBackendFileIndex *index, GList *fields)
+{
+  EBookBackendFileIndexPrivate *priv = GET_PRIVATE (index);
+
+  GList *l = NULL;
+  DBC *dbc = NULL; /* primary cursor */
+  DBT id_dbt, vcard_dbt;
+  EContact *contact = NULL;
+  gint db_error = 0;
+  DB *db = NULL;
+
+  db = priv->db;
+
+  db_error = db->cursor (db, NULL, &dbc, 0);
+
+  if (db_error != 0)
+  {
+    g_warning (G_STRLOC ": db->cursor failed: %s", db_strerror (db_error)); 
+    return FALSE;
+  }
+
+  memset (&id_dbt, 0, sizeof (id_dbt));
+  memset (&vcard_dbt, 0, sizeof (vcard_dbt));
+
+  db_error = dbc->c_get (dbc, &id_dbt, &vcard_dbt, DB_FIRST);
+
+  while (db_error == 0)
+  {
+    if (!g_str_equal (id_dbt.data, E_BOOK_BACKEND_FILE_VERSION_NAME))
+    {
+      /* parse the vcard */
+      contact = e_contact_new_from_vcard (vcard_dbt.data);
+
+      if (contact)
+      {
+        /* now we interate through all the indexes that need doing */
+        for (l = fields; l != NULL; l = l->next)
+        {
+          index_add_contact (index, contact, (EBookBackendFileIndexData *)l->data);
+        }
+      }
+    }
+
+    db_error = dbc->c_get (dbc, &id_dbt, &vcard_dbt, DB_NEXT);
+  }
+
+  if (db_error != DB_NOTFOUND)
+  {
+    g_warning (G_STRLOC ":dbc->c_get failed: %s", db_strerror (db_error));
+    return FALSE;
+  }
+
+  db_error = dbc->c_close (dbc);
+
+  if (db_error != 0)
+  {
+    g_warning (G_STRLOC ":dbc->c_close failed: %s", db_strerror (db_error));
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/* 
+ * for a given index add this contact, for the single string field case we
+ * just add a single entry to the index database. for the multiple case we add
+ * all the values for the field
+ */
+static void
+index_add_contact (EBookBackendFileIndex *index, EContact *contact, 
+    EBookBackendFileIndexData *data)
+{
+  EBookBackendFileIndexPrivate *priv = GET_PRIVATE (index);
+  gchar *uid = NULL;
+  DBT index_dbt, id_dbt;
+  DB *db = NULL;
+  GList *attrs; 
+  GList *values;
+  gint db_error = 0;
+  gchar *tmp = NULL;
+
+  /* we need the uid, this becomes the data for our index databases */
+  uid = (gchar *)e_contact_get (contact, E_CONTACT_UID);
+  dbt_fill_with_string (&id_dbt, uid);
+
+  /* we need the index database too */
+  db = g_hash_table_lookup (priv->sdbs, data->query_term);
+
+  for (attrs = e_vcard_get_attributes (E_VCARD (contact)); 
+      attrs != NULL; 
+      attrs = attrs->next)
+  {
+    EVCardAttribute *attr = (EVCardAttribute *)attrs->data;
+
+    if (g_str_equal (e_vcard_attribute_get_name (attr), data->vfield))
+    {
+      for (values = e_vcard_attribute_get_values (attr);
+          values != NULL; 
+          values = values->next)
+      {
+        tmp = g_utf8_casefold (values->data, -1);
+        dbt_fill_with_string (&index_dbt, tmp);
+
+        g_debug (G_STRLOC ": adding to index with key %s and data %s", 
+            index_dbt.data, id_dbt.data);
+
+        db_error = db->put (db, NULL, &index_dbt, &id_dbt, 0);
+
+        if (db_error != 0)
+        {
+          g_warning (G_STRLOC ": db->put failed: %s", db_strerror (db_error));
+        }
+      }
+    }
+  }
+
+  db_error = db->sync (db, 0);
+
+  if (db_error != 0)
+  {
+    g_warning ("db->sync failed: %s", db_strerror (db_error));
+  }
+}
+
+/* for a given index datbase remove all entries that have a data that matches
+ * the given uid. to do this we have to iterate through all the key/data pairs
+ * in the index and remove them if the data matches
+ *
+ * it is expected that this function will be called by for each index
+ */
+static void
+index_remove_contact (EBookBackendFileIndex *index, const gchar *uid, 
+    EBookBackendFileIndexData *data)
+{
+  EBookBackendFileIndexPrivate *priv = GET_PRIVATE (index);
+  
+  DBT index_dbt, id_dbt;
+  DB *db = NULL;
+  gint db_error = 0;
+  DBC *dbc = NULL; /* cursor */
+
+  /* we need the index database too */
+  db = g_hash_table_lookup (priv->sdbs, data->query_term);
+
+  /* create the cursor for the interation */
+  db_error = db->cursor (db, NULL, &dbc, 0);
+
+  if (db_error != 0)
+  {
+    g_warning (G_STRLOC ": db->cursor failed: %s", db_strerror (db_error)); 
+    return;
+  }
+
+  memset (&index_dbt, 0, sizeof (index_dbt));
+  memset (&id_dbt, 0, sizeof (id_dbt));
+
+  db_error = dbc->c_get (dbc, &index_dbt, &id_dbt, DB_FIRST);
+
+  while (db_error == 0)
+  {
+    g_debug (G_STRLOC ": Considering %s against %s", id_dbt.data, uid);
+    /* if the id is the one we're lookin for then delete! */
+    if (g_str_equal ((gchar *)id_dbt.data, uid))
+    {
+      g_debug (G_STRLOC ": removing from index with id: %s", (gchar *)id_dbt.data);
+      db_error = dbc->c_del (dbc, 0);
+
+      if (db_error != 0)
+      {
+        g_warning (G_STRLOC ": dbc->del failed: %s", db_strerror (db_error));
+        db_error = dbc->c_close (dbc);
+        return;
+      }
+    }
+
+    db_error = dbc->c_get (dbc, &index_dbt, &id_dbt, DB_NEXT);
+  }
+
+  if (db_error != DB_NOTFOUND)
+  {
+    g_warning (G_STRLOC ": dbc->c_get failed: %s", db_strerror (db_error));
+    db_error = dbc->c_close (dbc);
+    return;
+  }
+
+  db_error = dbc->c_close (dbc);
+
+  if (db_error != 0)
+  {
+    g_warning (G_STRLOC ": dbc->c_close failed: %s", db_strerror (db_error));
+    return;
+  }
+
+  db_error = db->sync (db, 0);
+
+  if (db_error != 0)
+  {
+    g_warning (G_STRLOC ": db->sync failed: %s", db_strerror (db_error));
+  }
+}
+
+static ESExpResult *
+is_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+{
+  EBookBackendFileIndex *index = (EBookBackendFileIndex *)userdata;
+  EBookBackendFileIndexPrivate *priv = GET_PRIVATE (index);
+  
+  ESExpResult *result = NULL;
+  DBT index_dbt, id_dbt;
+  DB *db = NULL;
+  gint db_error = 0;
+  gchar *query_term = NULL, *query_key = NULL;
+  GPtrArray *ids = NULL;
+  DBC *dbc = NULL;
+
+  ids = g_ptr_array_new ();
+
+  /* we must have two arguments and they must both be strings */
+  if (argc == 2 &&
+      argv[0]->type == ESEXP_RES_STRING &&
+      argv[1]->type == ESEXP_RES_STRING)
+  {
+    /* we need the index database too */
+    query_term = argv[0]->value.string;
+    db = g_hash_table_lookup (priv->sdbs, query_term);
+
+    /* populate a dbt for looking up in the index */
+    query_key = g_utf8_casefold (argv[1]->value.string, -1);
+    dbt_fill_with_string (&index_dbt, query_key);
+
+    /* we want bdb to use g_malloc this memory for us */
+    memset (&id_dbt, 0, sizeof (id_dbt));
+    id_dbt.flags = DB_DBT_MALLOC;
+
+    /* cursor */
+    db_error = db->cursor (db, NULL, &dbc, 0);
+
+    if (db_error != 0)
+    {
+      g_warning (G_STRLOC ": db->cursor failed: %s", db_strerror (db_error)); 
+      goto out;
+    } else {
+      db_error = dbc->c_get (dbc, &index_dbt, &id_dbt, DB_SET);
+
+      while (db_error == 0)
+      {
+        g_debug (G_STRLOC ": index query found: %s", id_dbt.data);
+        g_ptr_array_add (ids, id_dbt.data);
+
+        /* we add it to the list of strings to be freed */
+        priv->ids_to_free = g_list_prepend (priv->ids_to_free, id_dbt.data);
+
+        /* clear the index dbt since this time bdb will push memory into it */
+        memset (&index_dbt, 0, sizeof (index_dbt));
+        db_error = dbc->c_get (dbc, &index_dbt, &id_dbt, DB_NEXT_DUP);
+      }
+
+      if (db_error != DB_NOTFOUND)
+      {
+        g_warning (G_STRLOC ": dbc->c_get failed: %s", db_strerror (db_error));
+        goto out;
+      }
+
+      db_error = dbc->c_close (dbc);
+
+      if (db_error != 0)
+      {
+        g_warning (G_STRLOC ": dbc->c_close failed: %s", db_strerror (db_error));
+        goto out;
+      }
+    }
+  } else {
+    g_warning (G_STRLOC ": Unexpected query structure");
+  }
+
+out:
+
+  g_free (query_key);
+  result = e_sexp_result_new (sexp, ESEXP_RES_ARRAY_PTR);
+  result->value.ptrarray = ids;
+
+  return result;
+}
+
+static ESExpResult *
+beginswith_query (ESExp *sexp, gint argc, ESExpResult **argv, gpointer userdata)
+{
+  EBookBackendFileIndex *index = (EBookBackendFileIndex *)userdata;
+  EBookBackendFileIndexPrivate *priv = GET_PRIVATE (index);
+  
+  ESExpResult *result = NULL;
+  DBT index_dbt, id_dbt;
+  DB *db = NULL;
+  gint db_error = 0;
+  gchar *query_term = NULL, *query_key = NULL;
+  GPtrArray *ids = NULL;
+  DBC *dbc = NULL;
+
+  ids = g_ptr_array_new ();
+
+  /* we must have two arguments and they must both be strings */
+  if (argc == 2 &&
+      argv[0]->type == ESEXP_RES_STRING &&
+      argv[1]->type == ESEXP_RES_STRING)
+  {
+    /* we need the index database too */
+    query_term = argv[0]->value.string;
+    db = g_hash_table_lookup (priv->sdbs, query_term);
+
+    /* populate a dbt for looking up in the index */
+    query_key = g_utf8_casefold (argv[1]->value.string, -1);
+    dbt_fill_with_string (&index_dbt, query_key);
+
+    /* we want bdb to use g_malloc this memory for us */
+    memset (&id_dbt, 0, sizeof (id_dbt));
+    id_dbt.flags = DB_DBT_MALLOC;
+
+    /* we want bdb to actually manage chunk of memory for returning the
+     * actual key to us
+     */
+    index_dbt.flags = 0;
+
+    /* cursor */
+    db_error = db->cursor (db, NULL, &dbc, 0);
+
+    if (db_error != 0)
+    {
+      g_warning (G_STRLOC ": db->cursor failed: %s", db_strerror (db_error)); 
+      goto out;
+    } else {
+      db_error = dbc->c_get (dbc, &index_dbt, &id_dbt, DB_SET_RANGE);
+
+      while (db_error == 0)
+      {
+        if (g_str_has_prefix (index_dbt.data, query_key))
+        {
+          g_debug (G_STRLOC ": index query found: %s for %s for %s", id_dbt.data, query_key, index_dbt.data);
+          g_ptr_array_add (ids, id_dbt.data);
+
+          /* we add it to the list of strings to be freed */
+          priv->ids_to_free = g_list_append (priv->ids_to_free, id_dbt.data);
+          memset (&index_dbt, 0, sizeof (index_dbt));
+          db_error = dbc->c_get (dbc, &index_dbt, &id_dbt, DB_NEXT);
+        } else {
+          break;
+        }
+      }
+
+      if (db_error != 0 && db_error != DB_NOTFOUND)
+      {
+        g_warning (G_STRLOC ": dbc->c_get failed: %s", db_strerror (db_error));
+        goto out;
+      }
+
+      db_error = dbc->c_close (dbc);
+
+      if (db_error != 0)
+      {
+        g_warning (G_STRLOC ": dbc->c_close failed: %s", db_strerror (db_error));
+        goto out;
+      }
+    }
+  } else {
+    g_warning (G_STRLOC ": Unexpected query structure");
+  }
+
+out:
+  g_free (query_key);
+
+  result = e_sexp_result_new (sexp, ESEXP_RES_ARRAY_PTR);
+  result->value.ptrarray = ids;
+
+  return result;
+}
+
+static gboolean
+index_close_db_func (gpointer key, gpointer value, gpointer userdata)
+{
+  DB *db = (DB *)value;
+  gint db_error = 0;
+
+  db_error = db->close (db, 0);
+
+  if (db_error != 0)
+  {
+    g_warning (G_STRLOC ": close failed: %s", db_strerror (db_error));
+  }
+
+  return TRUE;
+}
Index: git/addressbook/backends/file/e-book-backend-file-index.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ git/addressbook/backends/file/e-book-backend-file-index.h	2008-05-12 11:33:42.000000000 +0100
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2008 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of version 2 of the GNU Lesser General Public License as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Author: Rob Bradford <rob@openedhand.com>
+ */
+
+#ifndef _E_BOOK_BACKEND_FILE_INDEX
+#define _E_BOOK_BACKEND_FILE_INDEX
+
+#include <glib-object.h>
+#include "libebook/e-contact.h"
+#include "db.h"
+
+G_BEGIN_DECLS
+
+#define E_TYPE_BOOK_BACKEND_FILE_INDEX e_book_backend_file_index_get_type()
+
+#define E_BOOK_BACKEND_FILE_INDEX(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), E_TYPE_BOOK_BACKEND_FILE_INDEX, EBookBackendFileIndex))
+
+#define E_BOOK_BACKEND_FILE_INDEX_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST ((klass), E_TYPE_BOOK_BACKEND_FILE_INDEX, EBookBackendFileIndexClass))
+
+#define E_IS_BOOK_BACKEND_FILE_INDEX(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), E_TYPE_BOOK_BACKEND_FILE_INDEX))
+
+#define E_IS_BOOK_BACKEND_FILE_INDEX_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), E_TYPE_BOOK_BACKEND_FILE_INDEX))
+
+#define E_BOOK_BACKEND_FILE_INDEX_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), E_TYPE_BOOK_BACKEND_FILE_INDEX, EBookBackendFileIndexClass))
+
+typedef struct {
+  GObject parent;
+} EBookBackendFileIndex;
+
+typedef struct {
+  GObjectClass parent_class;
+} EBookBackendFileIndexClass;
+
+GType e_book_backend_file_index_get_type (void);
+
+EBookBackendFileIndex *e_book_backend_file_index_new (void);
+gboolean e_book_backend_file_index_is_usable (EBookBackendFileIndex *index, const gchar *query);
+gboolean e_book_backend_file_index_setup_indicies (EBookBackendFileIndex *index, DB *db, 
+    const gchar *index_filename);
+void e_book_backend_file_index_add_contact (EBookBackendFileIndex *index, EContact *contact);
+void e_book_backend_file_index_remove_contact (EBookBackendFileIndex *index, const gchar *uid);
+void e_book_backend_file_index_modify_contact (EBookBackendFileIndex *index, EContact *contact);
+GPtrArray *e_book_backend_file_index_query (EBookBackendFileIndex *index, const gchar *query);
+void e_book_backend_file_index_finish_query (EBookBackendFileIndex *index);
+G_END_DECLS
+
+#endif /* _E_BOOK_BACKEND_FILE_INDEX */
+
