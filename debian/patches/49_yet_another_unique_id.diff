Index: evolution-data-server/addressbook/backends/file/e-book-backend-file.c
===================================================================
--- evolution-data-server.orig/addressbook/backends/file/e-book-backend-file.c	2008-11-28 12:25:25.000000000 +0200
+++ evolution-data-server/addressbook/backends/file/e-book-backend-file.c	2008-11-28 13:01:09.000000000 +0200
@@ -59,6 +59,8 @@
 #define d(x)
 
 #define CHANGES_DB_SUFFIX ".changes.db"
+#define RUNNING_ID_DB_NAME "running_id"
+#define RUNNING_ID_LEN 8
 
 #define E_BOOK_BACKEND_FILE_VERSION_NAME "PAS-DB-VERSION"
 #define E_BOOK_BACKEND_FILE_VERSION "0.2"
@@ -72,9 +74,11 @@
 	char     *filename;
 	char     *index_filename;
 	DB       *file_db;
+	DB       *id_db;
 	DB_ENV   *env;
 	EBookBackendFileIndex *index;
 	char     *sort_order;
+    int       running_id;
 };
 
 G_LOCK_DEFINE_STATIC (global_env);
@@ -131,7 +135,6 @@
 	static guint c = 0;
 	return g_strdup_printf (PAS_ID_PREFIX "%08lX%08X", time(NULL), c++);
 }
-#endif
 
 static char *
 e_book_backend_file_create_unique_id (void)
@@ -150,6 +153,110 @@
 
     return g_base64_encode (buffer, 6);
 }
+#endif
+
+static void
+load_last_running_id (EBookBackendFile *bf)
+{
+	DB *db = NULL;
+	DBC *dbc = NULL;
+	DBT rid_dbt, id_dbt;
+	int db_error;
+
+	db = bf->priv->id_db;
+
+	db_error = db->cursor (db, NULL, &dbc, 0);
+	if (db_error != 0) {
+		g_warning (G_STRLOC ": db->cursor failed: %s", db_strerror (db_error)); 
+		g_assert_not_reached ();
+	}
+
+	memset (&rid_dbt, 0, sizeof (rid_dbt));
+	memset (&id_dbt, 0, sizeof (id_dbt));
+
+	id_dbt.flags = DB_DBT_MALLOC;
+
+	db_error = dbc->c_get (dbc, &rid_dbt, &id_dbt, DB_FIRST);
+	if (db_error == DB_NOTFOUND) {
+		bf->priv->running_id = 0;
+	} else if (db_error != 0) {
+		g_warning (G_STRLOC ": c_get failed: %s", db_strerror (db_error));
+		g_assert_not_reached ();
+	} else {
+		/* id from string to uint */
+		long int ret = strtol ((const char *)id_dbt.data, (char **)NULL, 10);
+		if (ret == LONG_MIN) {
+			g_warning ("String to long integer conversion failed");
+			g_assert_not_reached ();
+		}
+
+		bf->priv->running_id = ret;
+
+		db_error = dbc->c_del (dbc, 0);
+		if (db_error != 0) {
+			g_warning (G_STRLOC ": c_del failed: %s", db_strerror (db_error));
+		}
+	}
+
+	db_error = dbc->c_close (dbc);
+	if (db_error != 0) {
+		g_warning (G_STRLOC ":c_close failed: %s", db_strerror (db_error));
+	}
+}
+
+static char*
+unique_id_to_string (int id)
+{
+	char ret[RUNNING_ID_LEN+1];
+
+	snprintf (&ret[0], RUNNING_ID_LEN+1, "%0*d", RUNNING_ID_LEN, id);
+	ret[RUNNING_ID_LEN] = '\0';
+	return g_strdup (ret);
+}
+
+static gboolean
+e_book_backend_file_store_unique_id (EBookBackendFile *bf)
+{
+	DB *db = NULL;
+	DBT rid_dbt, id_dbt;
+	int db_error;
+	gchar *uid;
+
+	db = bf->priv->id_db;
+	memset (&rid_dbt, 0, sizeof (rid_dbt));
+	memset (&id_dbt, 0, sizeof (id_dbt));
+
+	g_assert (bf->priv->running_id > 0);
+	
+	uid = unique_id_to_string (bf->priv->running_id);
+	string_to_dbt((const char *)uid, &id_dbt);
+
+	db_error = db->put (db, NULL, &rid_dbt, &id_dbt, 0);
+	g_free (uid);
+ 	if (db_error != 0) {
+		g_warning (G_STRLOC ": put failed: %s", db_strerror (db_error));
+		return FALSE;
+	}
+
+	db_error = db->sync (db, 0);
+	if (db_error != 0) {
+		g_warning (G_STRLOC ": sync failed: %s", db_strerror (db_error));
+		return FALSE;
+	}
+	return TRUE;
+}
+
+static char *
+e_book_backend_file_create_unique_id (EBookBackendFile *bf)
+{
+	if (0 == bf->priv->running_id) {
+		load_last_running_id (bf);
+	}
+	++bf->priv->running_id;
+
+	g_assert (bf->priv->running_id > 0);
+	return unique_id_to_string (bf->priv->running_id);
+}
 
 static void 
 set_revision (EContact *contact)
@@ -182,7 +289,7 @@
         g_assert (vcard_req);
         g_assert (contact);
 
-        id = e_book_backend_file_create_unique_id ();
+        id = e_book_backend_file_create_unique_id (bf);
 
         string_to_dbt (id, &id_dbt);
 
@@ -229,14 +336,17 @@
         db_error = insert_contact (bf, vcard_req, contact);
 
 	if (0 == db_error) {
+		/* Sync the database */
 		global_env.had_error = FALSE;
-		db_error = db->sync (db, 0);
-		if (global_env.had_error)
-                        db_error = ENOSPC;
+		if (e_book_backend_file_store_unique_id (bf)) {
+			db_error = db->sync (db, 0);
+		}
 		if (db_error != 0) {
 			g_warning ("db->sync failed with %s", db_strerror (db_error));
 		}
-        }
+		if (global_env.had_error)
+			db_error = ENOSPC;
+	}
 
         return db_error_to_status (db_error);
 }
@@ -269,7 +379,7 @@
         EBookBackendFile *bf;
         EContact *contact;
         DB *db;
-        int db_error;
+        int db_error = 0;
         EBookBackendSyncStatus status;
 
         bf = E_BOOK_BACKEND_FILE (backend);
@@ -298,11 +408,16 @@
                 *contacts = g_list_prepend (*contacts, contact);
         }
 
-        /* Sync the database */
-        global_env.had_error = FALSE;
-        db_error = db->sync (db, 0);
-        if (global_env.had_error)
-                db_error = ENOSPC;
+	/* Sync the database */
+	global_env.had_error = FALSE;
+	if (e_book_backend_file_store_unique_id (bf)) {
+		db_error = db->sync (db, 0);
+	}
+	if (db_error != 0) {
+		g_warning ("db->sync failed with %s", db_strerror (db_error));
+	}
+	if (global_env.had_error)
+		db_error = ENOSPC;
 
         status = db_error_to_status (db_error);
         if (status == GNOME_Evolution_Addressbook_Success) {
@@ -1392,6 +1507,55 @@
 }
 
 static GNOME_Evolution_Addressbook_CallStatus
+e_book_backend_file_setup_running_ids (EBookBackendFile *bf)
+{
+	DB *sdb;
+	DB_ENV *env;
+	int db_error;
+
+	g_debug (G_STRLOC ": %s", G_STRFUNC);
+
+	db_error = bf->priv->file_db->get_env (bf->priv->file_db, &env);
+	if (db_error != 0) {
+		g_warning ("getting env failed with %s", db_strerror (db_error));
+		goto error;
+	}
+
+	db_error = db_create (&sdb, env, 0);
+	if (db_error != 0) {
+		g_warning ("running index db_create failed with %s", db_strerror (db_error));
+		goto error;
+	}
+
+
+	db_error = sdb->open (sdb, NULL, bf->priv->index_filename, RUNNING_ID_DB_NAME /*NULL*/, 
+			      DB_HASH, DB_CREATE | DB_EXCL | DB_THREAD, 0666);
+
+	if (db_error != 0) {
+		db_error = sdb->open (sdb, NULL, bf->priv->index_filename, RUNNING_ID_DB_NAME /*NULL*/,
+				      DB_HASH, DB_CREATE | DB_THREAD, 0666);
+		if (db_error != 0) {
+			g_warning (G_STRLOC ": running index open failed with %s", db_strerror (db_error));
+			sdb->close (sdb, 0);
+			goto error;
+		}
+	}
+
+	bf->priv->id_db = sdb;
+
+	return GNOME_Evolution_Addressbook_Success;
+
+ error:
+	g_free (bf->priv->dirname);
+	g_free (bf->priv->filename);
+	bf->priv->file_db->close (bf->priv->file_db, 0);
+	bf->priv->file_db = NULL;
+
+	return db_error_to_status (db_error);
+
+}
+
+static GNOME_Evolution_Addressbook_CallStatus
 e_book_backend_file_load_source (EBookBackend           *backend,
 				 ESource                *source,
 				 gboolean                only_if_exists)
@@ -1596,7 +1760,7 @@
 		g_warning ("No file_db");
 	}
 
-	return GNOME_Evolution_Addressbook_Success;
+	return e_book_backend_file_setup_running_ids (bf);
 }
 
 static gboolean
@@ -1739,6 +1903,11 @@
 
 	bf = E_BOOK_BACKEND_FILE (object);
 
+	if (bf->priv->id_db) {
+		bf->priv->id_db->close (bf->priv->id_db, 0);
+		bf->priv->id_db = NULL;
+	}
+
 	if (bf->priv->file_db) {
 		bf->priv->file_db->close (bf->priv->file_db, 0);
 		bf->priv->file_db = NULL;
